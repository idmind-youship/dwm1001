    /*! ----------------------------------------------------------------------------
 *  @file       idmind_anchor_phases.c
 *  @brief      Code for Anchor device. Definition of phase handling functions
 *  @author     cneves
 */

#include "idmind_anchor.h"

/*! --------------------------------------------------------------------------
 * @fn print_msg()
 * @brief Auxiliary function to print messages
 * @param  none
 * @return none
 */
void print_msg(char* msg, int size)
{
    printk("M: ");
    for(int i = 0; i < size; i++) printk("0x%02X ", msg[i]);
    printk("\n");
}

/*! --------------------------------------------------------------------------
 * @fn get_tx_timestamp_u64()
 *
 * @brief Get the TX time-stamp in a 64-bit variable.
 *        /!\ This function assumes that length of time-stamps is 40 bits, 
 *            for both TX and RX!
 *
 * @param  none
 *
 * @return  64-bit value of the read time-stamp.
 */
uint64 get_tx_timestamp_u64(void)
{
    uint8 ts_tab[5];
    uint64 ts = 0;

    dwt_readtxtimestamp(ts_tab);
    for (int i = 4; i >= 0; i--) {
        ts <<= 8;
        ts |= ts_tab[i];
    }
    return ts;
}

/*! --------------------------------------------------------------------------
 * @fn get_rx_timestamp_u64()
 *
 * @brief Get the RX time-stamp in a 64-bit variable.
 *        /!\ This function assumes that length of time-stamps is 40 bits, 
 *             for both TX and RX!
 *
 * @param  none
 *
 * @return  64-bit value of the read time-stamp.
 */
uint64 get_rx_timestamp_u64(void)
{
    uint8 ts_tab[5];
    uint64 ts = 0;

    dwt_readrxtimestamp(ts_tab);
    for (int i = 4; i >= 0; i--) {
        ts <<= 8;
        ts |= ts_tab[i];
    }
    return ts;
}

/*! --------------------------------------------------------------------------
 * @fn final_msg_get_ts()
 *
 * @brief Read a given timestamp value from the final message. 
 *        In the timestamp fields of the final message, the least
 *        significant byte is at the lower address.
 *
 * @param  ts_field  pointer on the first byte of the timestamp field to read
 *         ts  timestamp value
 *
 * @return none
 */
void final_msg_get_ts(const uint8 *ts_field, uint32 *ts)
{
    *ts = 0;
    for (int i = 0; i < 4; i++) {
        *ts += ts_field[i] << (i * 8);
    }
}

/*! --------------------------------------------------------------------------
 * @fn discovery_phase()
 * @brief In the discovery phase, the anchor receives blink messages and replies
 *          with ranging init
 * @param  none
 * @return 0 if successful pairing, -1 otherwise
 */
int discovery_phase(int* seq_nr, uint32 dev_id, bool* dev_list, uint8* ranging_init_msg)
{
    int ret_val = -1;
    uint8 rx_timestamp[] = {0, 0, 0, 0, 0};

    printk("Starting discovery phase\n");

    if (rx_message(rx_buffer) != 0) return -1;

    if (rx_buffer[0] == 0xC5){
        int tag_id = 0;
        for(int i=0; i<8;i++) tag_id += rx_buffer[2+i];
        dwt_readrxtimestamp(rx_timestamp);
        printk("Received a Blink message from 0x%02X [%d]!\n", tag_id, rx_buffer[1]);
        // Send a ranging init message
        ranging_init_msg[2] = *seq_nr;
        (*seq_nr)++;
        // Destination Address (full)
        for (int i=0; i < 8; i++){
            ranging_init_msg[5+i] = rx_buffer[2+i];
        }
        // Tag short address (generated by anchor)
        ranging_init_msg[16] = 0x01;
        ranging_init_msg[17] = 0x00;

        // printk("RInit[%d]: ", sizeof(*ranging_init_msg));
        // print_msg(ranging_init_msg, 22);
        
        dwt_writetxdata(22*sizeof(*ranging_init_msg), ranging_init_msg, 0);
        dwt_writetxfctrl(22*sizeof(*ranging_init_msg), 0, 0); 
        if (dwt_starttx(DWT_START_TX_IMMEDIATE) != DWT_SUCCESS){
            printk("Failed to send Ranging Init message.\n");
            ret_val = -1;
        }
        else{
            ranging_tx_ts = get_tx_timestamp_u64();
            printk("Sent a Ranging Init message\n");
            ret_val = 0;
        }
    }
    else{
        printk("Message received was NOT a blink, it was [0x%02X 0x%02X]\n", rx_buffer[0], rx_buffer[1]);
    }
    rx_received = false;
    return ret_val;
}

/*! --------------------------------------------------------------------------
 * @fn ranging_phase()
 * @brief In the ranging phase, the anchor receives poll message, sends a reply,
 *          receives final message and gets a distance estimation
 * @param  none
 * @return 0 if successful ranging, -1 otherwise
 */
int ranging_phase(int* seq_nr, uint32 dev_id, bool* dev_list, uint8* resp_msg)
{
    printk("Starting ranging.\n");
    /*********************************************/
    /*                WAIT FOR POLL              */
    /*********************************************/
    if (rx_message(rx_buffer) != 0) return -1;
    // printk("Received message: ");
    // print_msg(rx_buffer, 12);
    if ((rx_buffer[0] == 0x41) & (rx_buffer[1] == 0x88) & (rx_buffer[9] == 0x61)){
        int tag_id = rx_buffer[7] + 256*rx_buffer[8];
        printk("Received a Poll message from 0x%02X!\n", tag_id);
        /* Retrieve poll reception timestamp. */
        poll_rx_ts = get_rx_timestamp_u64();
        resp_tx_ts = (poll_rx_ts + (POLL_RX_TO_RESP_TX_DLY_UUS * UUS_TO_DWT_TIME));
        // Send a response message
        resp_msg[2] = *seq_nr;
        (*seq_nr)++;
        // Destination address
        resp_msg[5] = (0x0001) & 0xFF;
        resp_msg[6] = (0x0001 >> 8) & 0xFF;
        // Calculated ToF
        uint32 tof = (poll_rx_ts - ranging_tx_ts - (POLL_RX_TO_RESP_TX_DLY_UUS * UUS_TO_DWT_TIME))/2;
        printk("Estimated ToF is %ld\n", tof);
        printk("Estimated distance is %ld\n", SPEED_OF_LIGHT*tof);
        for(int i=0; i < 4; i++) resp_msg[10+i] = (tof >> 4*i) & 0xFF;
        // printk("Sending response: ");
        // print_msg(resp_msg, 16);
        
        dwt_setdelayedtrxtime(resp_tx_ts);

        dwt_writetxdata(sizeof(resp_msg), resp_msg, 0);
        dwt_writetxfctrl(sizeof(resp_msg), 0, 0); 
        if (dwt_starttx(DWT_START_TX_DELAYED | DWT_RESPONSE_EXPECTED) == DWT_SUCCESS){
            printk("Sent a Poll Response\n");
            if (rx_message(rx_buffer) != 0){
                printk("No new message was received\n");
                return -1;
            }
            else{
                if ((rx_buffer[0] == 0x41) & (rx_buffer[1] == 0x88) & (rx_buffer[9] == 0x69)){
                    printk("Received a Final message\n");
                    return 0;
                }
                else{
                    printk("The message received was NOT a final message [0x%02X 0x%02X ... 0x%02X]\n", rx_buffer[0], rx_buffer[1], rx_buffer[9]);
                    return -1;
                }
            }
        }
        else{
            printk("Failed to send Poll Response message.\n");
            return -1;
        }
    }
    else{
        printk("The message received was NOT a Poll Message\n");
        return -1;
    }
    return 0;
}